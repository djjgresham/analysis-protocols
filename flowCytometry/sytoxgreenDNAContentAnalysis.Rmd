---                                                                    
title: "An example of how to proc some flow cyto data - specifically DNA content staining with sytoxgreen"
author: "Darach Miller"                                                   
date: "`r Sys.Date()`"                                                    
output:                                                                   
  html_document:                                                          
    self_contained: true                                                  
---                           

# Data readin

```{r, warning=F, cache=F}
require(ggplot2)
require(flowCore)
```

```{r,warning=F,cache=T}
if (length(dir("./exp154sytoxgreen/"))) {
  directories <- c(
      exp154sytoxgreen= "./exp154sytoxgreen/"
    ) 
}
directories
dir(directories[1])
```

```{r,warning=F,cache=T}
datz <- list()  # Here's a blank list to store raw data
for (expr in names(directories)) { # For every experiment name (one)
  dirz <- directories[expr]
  for (fz in dir(dirz)[grep("fcs",dir(dirz))]) { 
      # For every FCS in that directory
    if (grepl("(water)|(h2o)|(decon)|(pbs)",fz)) {next}
      # I don't want any samples with these words...
    nameToSaveAs <- paste0(expr, warning=F,"_",sub(".fcs","",fz))
      # I'm just making a short name to name the list position 
    print(paste0("doing ",dirz,"",fz,", saving it as ",nameToSaveAs))
      # Always good to say what's up
    datz[[nameToSaveAs]] <- data.frame(
        exprs(read.FCS(paste0(dirz,fz),transformation=FALSE))
      )
  }
}
```

Here we immediately use `flowCore` just to extract the measurements 
from the machine. Note the lack of any confounding transformation.
This is 2016, and I'm pretty sure these are linear digital detectors.

The below takes everything in `datz` and `rbind()`'s it together
to make one large data frame. This might take a while.

```{r,warning=F,cache=T}
if (exists("lrgdf")) {rm(lrgdf)}
  # If it exists, remove it
for (fz in names(datz)) {
  relevantBit <- gsub(".+?\\s(.+?)$","\\1",fz)
    # Here we just take out the name of the sample
  if (!exists("lrgdf")) {
    lrgdf <- data.frame(datz[[as.character(fz)]],
      colsplit(relevantBit,"_",
        names=c("sample","dye","pretreatment")))
    # if it doesn't exist, define a new data frame
  } else {
    lrgdf <- rbind(lrgdf,data.frame(datz[[as.character(fz)]],
      colsplit(relevantBit,"_",
        names=c("sample","dye","pretreatment"))))
    # if not, then just bind the data.frame onto the previous
  }
}
dim(lrgdf)
originallrgdf <- lrgdf
lrgdf <- subset(lrgdf,dye=="sytoxgreen"&pretreatment=="rnase_pk")
```

Now that we have that, we can start gating. I gate like a neadertal.
Note that I'm plotting a random subset of rows in order to make this 
plot more quickly.

```{r, warning=F, cache=T,error=F}
g <- ggplot(lrgdf[sample(1:nrow(lrgdf),1e4),])+
  aes(x=log(FSC.A),y=log(FSC.H))+
  geom_point(size=.5,alpha=.05)
g
g+geom_vline(xintercept=10.5)
g+geom_vline(xintercept=10.5)+geom_abline(slope=0.9,intercept=1.6)
subdf<-subset(lrgdf,log(FSC.A)>10.5&(log(FSC.H)>log(FSC.A)*0.9+1.6))
```

```{r,cache=T}
g <- ggplot(subdf[sample(1:nrow(subdf),size=1e4),])+
  aes(x=log(FSC.A),y=log(FL1.A))+
  geom_point(size=.5,alpha=.05)+
  facet_wrap(~sample)
g
g+geom_hline(yintercept=13)
subdf <- subset(subdf,log(FL1.A)>13)
```

```{r}
g <- ggplot(subdf)+
  aes(x=log(FSC.A),y=log(FL1.A))+
  geom_point(size=.5,alpha=.05)+
  facet_wrap(~sample)
g+coord_cartesian(xlim=c(10.5,14.5),ylim=c(13,15))
```

```{r}
ggplot(subdf)+
  aes(x=log10(FL1.A),col=sample)+
  stat_bin(aes(y = ..density..),binwidth=0.005,geom="line",
    position="identity",cex=.5)+
  stat_bin(aes(y = ..density..),binwidth=0.005,geom="point",
    position="identity",cex=.2)+
  coord_cartesian(xlim=c(5.9,6.6))+
  theme(legend.position="bottom")
```

One of these days, I'll write up how to use `mle2` to fit a mixed
model to estimate cell cycle contribution.

